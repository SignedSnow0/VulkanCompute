#ifndef UTILS_COMP
#define UTILS_COMP

const float PI = 3.14159265359f;
const float TWO_PI = 6.28318530718f;
const float INV_PI = 0.31830988618f;
const float INV_TWO_PI = 0.15915494309f;
const float EPSILON = 0.000001f;
const float MAX_FLOAT = 3.402823466e+38f;
const vec3 UP = vec3(0.0f, 1.0f, 0.0f);

float random(inout uint state) { //state Ã¨ seed
    state = state * 747796405u + 2891336453u;
    uint result = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    result = (result >> 22u) ^ result;
    return float(result) / 4294967295.0f;
}

float random(inout uint state, float min, float max) {
    return min + (max - min) * random(state);
}

float randomNormalDistribution(inout uint state) {
    float theta = TWO_PI * random(state);
    float rho = sqrt(-2.0f * log(random(state)));
    return rho * cos(theta);
}

vec3 randomOnSphere(inout uint state) {
    return normalize(vec3(randomNormalDistribution(state), 
                          randomNormalDistribution(state), 
                          randomNormalDistribution(state)));
}

vec3 randomOnHemisphere(inout uint state, vec3 normal) {
    vec3 dir = randomOnSphere(state);
    return dir * sign(dot(normal, dir));
}

float fast_inverse_sqrt (float number) {
    uint i; //codice originale: long
    float x2, y;
    const float threehalfs = 1.5f;

    x2 = number * 0.5f;
    y = number;
    //i =*(long*)&y;
    //i=0x5f3759df - (i>>1);
    //y  = *(float*)&i;
    //y=y*(threehalfs - (x2*y*y));

    return y;
}

vec3 checkerBoardColor(vec3 color1, vec3 color2, vec3 position) {
    float scale = 1.0;
    float pattern = (mod(floor(position.x * scale) + floor(position.z * scale), 2.0));
    if (pattern < 1.0) {
        return color1;
    } else {
        return color2;
    }
}

vec3 baricentricCoordinates(vec3 p, vec3 a, vec3 b, vec3 c) {
    vec3 v0 = b - a;
    vec3 v1 = c - a;
    vec3 v2 = p - a;
    float d00 = dot(v0, v0);
    float d01 = dot(v0, v1);
    float d11 = dot(v1, v1);
    float d20 = dot(v2, v0);
    float d21 = dot(v2, v1);
    float denom = d00 * d11 - d01 * d01;
    float v = (d11 * d20 - d01 * d21) / denom;
    float w = (d00 * d21 - d01 * d20) / denom;
    float u = 1.0 - v - w;
    return vec3(u, v, w);
}
#endif