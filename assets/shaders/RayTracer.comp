#version 460
#extension GL_ARB_shading_language_include : require

#include "Utils.comp"

const int MAX_BOUNCES = 10;
const int SAMPLE_COUNT = 100; //da sistemare (non va) -> smoothness delle linee

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    vec3 emission_color;
    float emission_strength;
    float metalness;
};

struct Sphere {
    vec3 position;
    Material material;
    float radius;
};

struct RayHit {
    vec3 position;
    vec3 normal;
    Material material; //colore del punto dell'oggetto che vado a colpire
    float distance;
};

struct Plane {
    vec3 position;
    vec3 normal;
    Material material;
};

struct Vertex {
    vec3 position;
    vec3 normal;
    vec2 uv;
};

layout(rgba8, binding = 0) uniform image2D window; //finestra finale di output

//uniform: dati/struttura condivisi tra tutti i thread dei blocchi
layout(binding = 1) uniform RandomSeed {
    uint seed;
} random_seed;

layout (binding=2) uniform SceneData {
    mat4 modelMatrix;
    uint numFrames;
} scene_data;

layout (binding = 3) readonly buffer VertexBuffer {
    Vertex vertices[];
} vertex_buffer;

layout (binding = 4) readonly buffer IndexBuffer {
    uint indices[];
} index_buffer;

layout (binding = 5) uniform Camera {
    mat4 viewMatrix;
    vec3 position;
    vec3 forward;
} camera;

Ray rayGen() {
    ivec2 dim_window = imageSize(window);
    Ray ray;
    ray.origin = -camera.position;

    // (0, 0) --------------------- (width, 0)
    //   |                               |
    //   |                               |
    //   |                               |
    // (0, height) --------------- (width, height)
    vec2 uv = gl_GlobalInvocationID.xy;

    // (0, 0) ---------------- (1, 0)
    //   |                       |
    //   |                       |
    //   |                       |
    // (0, 1) --------------- (1, 1)
    uv = uv / dim_window; //valori tra tra 0 e 1

    // (-1, -1) ---------------- (1, -1)
    //   |                       |
    //   |                       |
    //   |                       |
    // (-1, 1) --------------- (1, 1)
    uv = uv * 2.0 - 1.0;//valori tra -1 - 1
    uv.x *= float(dim_window.x) / dim_window.y; //ratio dell'immagine, proporzioni corrette per il rettangolo

    // (-1, 1) ---------------- (1, 1)
    //   |                       |
    //   |            x          |
    //   |                       |
    // (-1, -1) --------------- (1, -1)
    uv.y *= -1.0; //inverto l'asse delle y (y deve crescere verso l'alto)

    ray.direction = (camera.viewMatrix * normalize(vec4(uv, -1, 1))).xyz; //vettore di lunghezza unitaria
    return ray;
}

bool intersectTriangle(Ray ray, vec3 p0, vec3 p1, vec3 p2, out RayHit hit) {
     vec3 edge1 = p1 - p0;
    vec3 edge2 = p2 - p0;
    vec3 ray_cross_e2 = cross(ray.direction, edge2);
    float det = dot(edge1, ray_cross_e2);

    if (abs(det) < EPSILON)
        return false;    // This ray is parallel to this triangle.

    float inv_det = 1.0 / det;
    vec3 s = ray.origin - p0;
    float u = inv_det * dot(s, ray_cross_e2);

    if ((u < 0 && abs(u) > EPSILON) || (u > 1 && abs(u-1) > EPSILON))
        return false;

    vec3 s_cross_e1 = cross(s, edge1);
    float v = inv_det * dot(ray.direction, s_cross_e1);
    if ((v < 0 && abs(v) > EPSILON) || (u + v > 1 && abs(u + v - 1) > EPSILON))
        return false;

    // At this stage we can compute t to find out where the intersection point is on the line.
    float t = inv_det * dot(edge2, s_cross_e1);

    if (t > EPSILON) // ray intersection
    {
        hit.distance = t;
        hit.position = ray.origin + ray.direction * t;
        hit.normal = normalize(cross(edge1, edge2));
        Material material;
        material.color = vec3(1, 0, 0);
        material.emission_color = vec3(0, 0, 0);
        material.emission_strength = 0.0;
        material.metalness = 0.2;
        hit.material = material;

        return true;
    }
    
    return false;
}

bool intersectMesh(Ray ray, out RayHit hit) {
    hit.distance = MAX_FLOAT;
    bool hit_something = false;

    for (int i = 0; i < index_buffer.indices.length() / 3; i += 3) {
        uint index0 = index_buffer.indices[i];//ottimizazione con indexbuffer per eliminare vertici duplicati
        uint index1 = index_buffer.indices[i + 1];
        uint index2 = index_buffer.indices[i + 2];

        vec3 p0 = vertex_buffer.vertices[index0].position;
        vec3 p1 = vertex_buffer.vertices[index1].position;
        vec3 p2 = vertex_buffer.vertices[index2].position;
        p0 = (scene_data.modelMatrix * vec4(p0, 1)).xyz;
        p1 = (scene_data.modelMatrix * vec4(p1, 1)).xyz;
        p2 = (scene_data.modelMatrix * vec4(p2, 1)).xyz;

        RayHit current_hit;
        if (intersectTriangle(ray, p0, p1, p2, current_hit) && current_hit.distance < hit.distance) {
            hit = current_hit;
            hit_something = true;
        }
    }

    return hit_something;
}

bool intersectSphere(Ray ray, Sphere sphere, out RayHit hit) {
    // C = centro della sfera
    // P = posizione (variabile indipendente)
    // O = origine del raggio
    // D = direzione del raggio
    //
    // (Cx - Px)^2 + (Cy - Py)^2 + (Cz - Pz)^2 = r^2
    // (C - P) · (C - P) = r^2
    // P = O + tD
    // (C - (O + tD)) · (C - (O + tD)) = r^2
    // t^2(D · D) - 2tD · (C - O) + (C - O) · (C - O) - r^2 = 0
    // t^2a + tb + c = 0
    // a = D · D
    // b = -2D · (C - O)
    // c = (C - O) · (C - O) - r^2
    vec3 positionOffset = ray.origin - sphere.position;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(positionOffset, ray.direction);
    float c = dot(positionOffset, positionOffset) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0) {
        hit.distance = (-b - sqrt(discriminant)) / (2 * a);
        hit.position = ray.origin + ray.direction * hit.distance;
        hit.normal = normalize(hit.position - sphere.position);
        hit.material = sphere.material;

        return hit.distance >= 0;
    }

    return false;
}

bool intersectPlane(Ray ray, Plane plane, out RayHit hit) {
    float denominator = dot(plane.normal, ray.direction);
    if(abs(denominator)>EPSILON) { //escludo i raggi paralleli al piano
        float t = dot(plane.position - ray.origin, plane.normal)/denominator; //calcolo la distanza tra la posizione dell'origine del raggio e l'intersezione con il piano
        if(t>=0) { //interseca
            hit.distance = t;
            hit.position = ray.origin + ray.direction * hit.distance;
            hit.normal = plane.normal;
            hit.material = plane.material;
            hit.material.color = checkerBoardColor(vec3(1,1,1), vec3(0,0,0), hit.position);
            return true;
        }
    }
    return false;
}

bool intersectTrangle(Ray ray, vec3 p0, vec3 p1, vec3 p2, out RayHit hit) {
    vec3 edge1 = p1-p0;
    vec3 edge2 = p2-p0;
    vec3 ray_cross_e2 = cross(ray.direction, edge2); //cross: prodotto vettoriale
    float determinant = dot(edge1, ray_cross_e2);

    if(abs(determinant)<EPSILON) {
        return false;
    }
    //qui si potrebbe usare la funzione fast_inverse_sqrt per ottimizzazione delle prestazioni
    float inv_det = 1.0 / determinant;
    vec3 s = ray.origin - p0;
    float u = inv_det * dot(s, ray_cross_e2);

    if((u<0 && abs(u) > EPSILON) || (u>1 && abs(u-1) > EPSILON)) //da guardare
        return false;
    
    vec3 s_cross_e1 = cross(s, edge1);
    float v = inv_det * dot(s, s_cross_e1);

    if((v<0 && abs(v) > EPSILON) || (u+v>1 && abs(u+v-1) > EPSILON)) //da guardare
        return false;
    
    float t = inv_det * dot(edge2, s_cross_e1);
    

    if(t>EPSILON) {
        hit.distance = t;
        hit.position = ray.origin + ray.direction * hit.distance;
        hit.normal = normalize(cross(edge1, edge2));
        Material material;
        material.color = vec3(1,0,0);
        material.emission_color = vec3(0,0,0);
        material.emission_strength = 0;
        material.metalness = 0.2;
        hit.material = material;
        return true;
    } 

    return false;

}

bool closestHit(Ray ray, out RayHit hit) {
    Sphere spheres[3];
    
    spheres[2].position = vec3(-1, 0, -2);
    spheres[2].radius = 1;
    spheres[2].material.color = vec3(1, 1, 1);
    spheres[2].material.emission_color = vec3(0, 0, 0);
    spheres[2].material.emission_strength = 0.0;
    spheres[2].material.metalness = 1.0;
    
    spheres[1].position = vec3(1, 0, -2);
    spheres[1].radius = 1;
    spheres[1].material.color = vec3(1, 1, 1);
    spheres[1].material.emission_color = vec3(0, 0, 0);
    spheres[1].material.emission_strength = 0.0;
    spheres[1].material.metalness = 1.0;

    spheres[0].position = vec3(-4, 5, -10);
    spheres[0].radius = 5;
    spheres[0].material.color = vec3(0, 0, 0);
    spheres[0].material.emission_color = vec3(1, 1, 1);
    spheres[0].material.emission_strength = 1.0;
    spheres[0].material.metalness = 0.0;

    Plane plane;
    plane.position = vec3(0,-1,0);
    plane.normal = vec3 (0,1,0);
    plane.material.color = vec3 (0,0,1);
    plane.material.emission_color= vec3(0,0,0);
    plane.material.emission_strength=0;
    plane.material.metalness=0.0;

    hit.distance = MAX_FLOAT;
    bool hit_something = false;
    for (int i = 0; i < spheres.length(); i++) {
        RayHit current_hit;
        if (intersectSphere(ray, spheres[i], current_hit) && current_hit.distance < hit.distance) {
            hit = current_hit; //se prendo qualcosa ed è più vicino lo sovrascrivo 
            hit_something = true;
        }
    }
    RayHit current_hit;
    if (intersectPlane(ray, plane, current_hit) && current_hit.distance < hit.distance) {
        hit = current_hit; //se prendo qualcosa ed è più vicino lo sovrascrivo 
        hit_something = true;
    }
    //if (intersectMesh(ray, current_hit) && current_hit.distance < hit.distance) {
    //    hit = current_hit; //se prendo qualcosa ed è più vicino lo sovrascrivo 
    //    hit_something = true;
    //}
    return hit_something;
}


vec3 trace(){
    vec3 result = vec3(0, 0, 0);
    vec3 ray_color = vec3(1, 1, 1);
    uint state = gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * random_seed.seed; //elemento randomico

    for(int j=0; j<SAMPLE_COUNT; j++) {
        Ray ray = rayGen();
        ray.origin += randomOnSphere(state)*EPSILON;
        RayHit hit;
        for (int i = 0; i < MAX_BOUNCES; i++) {
            if (closestHit(ray, hit)) {
                //creo un nuovo raggio che parte dalla sfera colpita
                ray.origin = hit.position+EPSILON*hit.normal; //per risolvere problema dovuto a errore di precisione del float (eventualmente da aggiungere)
                vec3 diffuseDirection = randomOnHemisphere(state, hit.normal);

                vec3 specularDirection = reflect(ray.direction, hit.normal); 
                ray.direction = mix(diffuseDirection, specularDirection, hit.material.metalness);

                vec3 emittedLight = hit.material.emission_color * hit.material.emission_strength;
                result += emittedLight * ray_color;
                ray_color *= (hit.material.color * dot(hit.normal, ray.direction));
            } else {
                result += vec3(0.5,0.7,1) * ray_color;
                return result;
            }
        }
        
    }
    return result;
}


layout(local_size_x = 8, local_size_y = 8) in; //dim del blocco (ogni blocco ha 64 thread)
void main() { //funzione che ogni thread esegue
    ivec2 dim_window = imageSize(window);
   
    if (gl_GlobalInvocationID.x > dim_window.x || gl_GlobalInvocationID.y > dim_window.y) { //controllo se sono dentro alla window
        return;
    }
    
    vec3 result = trace();

    if(scene_data.numFrames > 4) {
        float weight = 1.0 / (scene_data.numFrames + 1);
        vec3 previousColor = imageLoad(window, ivec2(gl_GlobalInvocationID.xy)).rgb;
        result = mix(previousColor, result, weight); 

        imageStore(window, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1));
    } else {
        imageStore(window, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1));
    }
}