#version 460
#extension GL_ARB_shading_language_include : require

#include "Utils.comp"

struct Ray {
    vec3 Origin;
    vec3 Direction;
};

struct Material {
    vec3 Color;
    float Metalness;
    vec3 EmissionColor;
    float EmissionStrength;
};

struct Sphere {
    vec3 Position;
    float Radius;
    uint MaterialIndex;
};

struct RayHit {
    vec3 Position;
    vec3 Normal;
    float Distance;
    uint MaterialIndex;
};

struct Plane {
    vec3 Position;
    vec3 Normal;
    uint MaterialIndex;
};

struct Vertex {
    vec3 Position;
    vec3 Normal;
    vec2 UV;
};

layout(rgba8, binding = 0) uniform image2D gWindow;

layout (binding = 1) uniform SceneData {
    uint NumFrames;
    uint Seed;
    uint MaxBounces;
} gSceneData;

layout (binding = 2) uniform Camera{
    vec3 Position;
    vec3 Forward;
} gCamera;

layout (std430, binding = 3) readonly buffer VertexBuffer {
    Vertex vertices[];
} gVertexBuffer;

layout (std430, binding = 4) readonly buffer IndexBuffer {
    uint indices[];
} gIndexBuffer;

layout (binding = 5) readonly buffer Spheres {
    Sphere spheres[];
} gSphereBuffer;

layout (binding = 6) readonly buffer Planes {
    Plane planes[];
} gPlaneBuffer;

layout (binding = 7) readonly buffer Materials {
    Material materials[];
} gMaterialBuffer;

Ray rayGen() {
    ivec2 dimWindow = imageSize(gWindow);
    vec3 right = normalize(cross(gCamera.Forward,UP));

    vec2 uv = gl_GlobalInvocationID.xy;
    uv = uv / dimWindow;
    uv = uv * 2.0 - 1.0;
    uv.x *= float(dimWindow.x) / dimWindow.y;
    uv.y *= -1.0;

    Ray ray;
    ray.Origin = gCamera.Position;
    ray.Direction = normalize(gCamera.Forward + uv.x * right + uv.y * UP);

    return ray;
}

bool intersectTriangle(Ray ray, vec3 p0, vec3 p1, vec3 p2, out RayHit hit) {
    vec3 edge1 = p1 - p0;
    vec3 edge2 = p2 - p0;
    vec3 rayCrossE2 = cross(ray.Direction, edge2);
    float det = dot(edge1, rayCrossE2);

    if (det > -EPSILON && det < EPSILON)
        return false;

    float invDet = 1.0 / det;
    vec3 s = ray.Origin - p0;
    float u = invDet * dot(s, rayCrossE2);

    if ((u < 0 && abs(u) > EPSILON) || (u > 1 && abs(u-1) > EPSILON))
        return false;

    vec3 sCrossE1 = cross(s, edge1);
    float v = invDet * dot(ray.Direction, sCrossE1);
    if ((v < 0 && abs(v) > EPSILON) || (u + v > 1 && abs(u + v - 1) > EPSILON))
        return false;

    float t = invDet * dot(edge2, sCrossE1);
    if (t > EPSILON)
    {
        hit.Distance = t;
        hit.Position = ray.Origin + ray.Direction * t;
        hit.Normal = normalize(cross(edge1, edge2));

        return true;
    }
    
    return false;
}

bool intersectMesh(Ray ray, int materialIndex, out RayHit hit, out vec3 albedoColor) {
    albedoColor = vec3(1, 1, 1);

    hit.Distance = MAX_FLOAT;
    bool hitSomething = false;

    for (uint i = 0; i < gIndexBuffer.indices.length(); ) {
        uint index0 = gIndexBuffer.indices[i++];//ottimizazione con indexbuffer per eliminare vertici duplicati
        uint index1 = gIndexBuffer.indices[i++];
        uint index2 = gIndexBuffer.indices[i++];

        vec3 p0 = gVertexBuffer.vertices[index0].Position;
        vec3 p1 = gVertexBuffer.vertices[index1].Position;
        vec3 p2 = gVertexBuffer.vertices[index2].Position;

        RayHit currentHit;
        if (intersectTriangle(ray, p0, p1, p2, currentHit) && currentHit.Distance < hit.Distance) {
            hit = currentHit;
            hit.MaterialIndex = materialIndex;
            hitSomething = true;
        }
    }

    return hitSomething;
}

bool intersectSphere(Ray ray, Sphere sphere, out RayHit hit) {
    vec3 positionOffset = ray.Origin - sphere.Position;
    float a = dot(ray.Direction, ray.Direction);
    float b = 2 * dot(positionOffset, ray.Direction);
    float c = dot(positionOffset, positionOffset) - sphere.Radius * sphere.Radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0) {
        hit.Distance = (-b - sqrt(discriminant)) / (2 * a);
        hit.Position = ray.Origin + ray.Direction * hit.Distance;
        hit.Normal = normalize(hit.Position - sphere.Position);
        hit.MaterialIndex = sphere.MaterialIndex;

        return hit.Distance >= 0;
    }

    return false;
}

bool intersectPlane(Ray ray, Plane plane, out RayHit hit) {
    float denominator = dot(plane.Normal, ray.Direction);
    if (abs(denominator) > EPSILON) {
        float t = dot(plane.Position - ray.Origin, plane.Normal) / denominator;
        if (t >= 0) {
            hit.Distance = t;
            hit.Position = ray.Origin + ray.Direction * hit.Distance;
            hit.Normal = plane.Normal;
            hit.MaterialIndex = plane.MaterialIndex;

            return true;
        }
    }
    return false;
}

bool closestHit(Ray ray, out RayHit hit, out vec3 albedoColor) {
    hit.Distance = MAX_FLOAT;
    bool hitSomething = false;
    RayHit currentHit;

    for (int i = 0; i < gSphereBuffer.spheres.length(); i++) {
        if (intersectSphere(ray, gSphereBuffer.spheres[i], currentHit) && currentHit.Distance < hit.Distance) {
            hit = currentHit;
            hitSomething = true;
        }
    }

    for (int i = 0; i < gPlaneBuffer.planes.length(); i++) {
        if (intersectPlane(ray, gPlaneBuffer.planes[i], currentHit) && currentHit.Distance < hit.Distance) {
            hit = currentHit;
            hitSomething = true;
        }
    }

    if (intersectMesh(ray, 0, currentHit, albedoColor) && currentHit.Distance < hit.Distance) {
        hit = currentHit;
        hitSomething = true;
    }

    return hitSomething;
}


vec3 trace() {
    vec3 result = vec3(0, 0, 0);
    vec3 rayColor = vec3(1, 1, 1);
    uint state = gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * gSceneData.Seed;

    Ray ray = rayGen();
    RayHit hit;
    vec3 albedoColor = vec3(1, 1, 1);
    for (int i = 0; i < gSceneData.MaxBounces; i++) {
        if (closestHit(ray, hit, albedoColor)) {
            ray.Origin = hit.Position + EPSILON * hit.Normal;

            Material hitMaterial = gMaterialBuffer.materials[hit.MaterialIndex];

            vec3 diffuseDirection = randomOnHemisphere(state, hit.Normal);
            vec3 specularDirection = reflect(ray.Direction, hit.Normal);
            ray.Direction = mix(diffuseDirection, specularDirection, hitMaterial.Metalness);

            vec3 emittedLight = hitMaterial.EmissionColor * hitMaterial.EmissionStrength;
            result += emittedLight * rayColor;
            rayColor *= (hitMaterial.Color * albedoColor * dot(hit.Normal, ray.Direction));
        } else {
            result += vec3(0.5, 0.7, 1) * rayColor;
            break;
        }
    }
    return result;
}

layout(local_size_x = 8, local_size_y = 8) in;
void main() {
    ivec2 dimWindow = imageSize(gWindow);
   
    if (gl_GlobalInvocationID.x > dimWindow.x || gl_GlobalInvocationID.y > dimWindow.y) {
        return;
    }
    
    vec3 result = trace();

    if (gSceneData.NumFrames > 4) {
        float weight = 1.0 / (gSceneData.NumFrames + 1);
        vec3 previousColor = imageLoad(gWindow, ivec2(gl_GlobalInvocationID.xy)).rgb;
        result = mix(previousColor, result, weight); 

        imageStore(gWindow, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1));
    } else {
        imageStore(gWindow, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1));
    }
}