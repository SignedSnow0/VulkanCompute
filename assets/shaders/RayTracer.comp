#version 460
#extension GL_ARB_shading_language_include : require

#include "Utils.comp"

const int MAX_BOUNCES = 4;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    vec3 emission_color;
    float emission_strength;
};

struct Sphere {
    vec3 position;
    Material material;
    float radius;
};

struct RayHit {
    vec3 position;
    vec3 normal;
    Material material; //colore del punto dell'oggetto che vado a colpire
    float distance;
};

layout(rgba8, binding = 0) uniform image2D window; //finestra finale di output

//uniform: dati/struttura condivisi tra tutti i thread dei blocchi
layout(binding = 1) uniform RandomSeed {
    uint seed;
} random_seed;

Ray rayGen() {
    ivec2 dim_window = imageSize(window);
    Ray ray;
    ray.origin = vec3(0.0, 0.0, 0.0);

    // (0, 0) --------------------- (width, 0)
    //   |                               |
    //   |                               |
    //   |                               |
    // (0, height) --------------- (width, height)
    vec2 uv = gl_GlobalInvocationID.xy;
    // (0, 0) ---------------- (1, 0)
    //   |                       |
    //   |                       |
    //   |                       |
    // (0, 1) --------------- (1, 1)
    uv = uv / dim_window;
    // (-1, -1) ---------------- (1, -1)
    //   |                       |
    //   |                       |
    //   |                       |
    // (-1, 1) --------------- (1, 1)
    uv = uv * 2.0 - 1.0;//ora tra -1 - 1
    uv.x *= float(dim_window.x) / dim_window.y;
    // (-1, 1) ---------------- (1, 1)
    //   |                       |
    //   |                       |
    //   |                       |
    // (-1, -1) --------------- (1, -1)
    uv.y *= -1.0;

    ray.direction = normalize(vec3(uv, -1));
    return ray;
}

bool intersectSphere(Ray ray, Sphere sphere, out RayHit hit) {
    // C = centro della sfera
    // P = posizione (variabile indipendente)
    // O = origine del raggio
    // D = direzione del raggio
    //
    // (Cx - Px)^2 + (Cy - Py)^2 + (Cz - Pz)^2 = r^2
    // (C - P) · (C - P) = r^2
    // P = O + tD
    // (C - (O + tD)) · (C - (O + tD)) = r^2
    // t^2(D · D) - 2tD · (C - O) + (C - O) · (C - O) - r^2 = 0
    // t^2a + tb + c = 0
    // a = D · D
    // b = -2D · (C - O)
    // c = (C - O) · (C - O) - r^2
    vec3 positionOffset = ray.origin - sphere.position;
    float a = dot(ray.direction, ray.direction);
    float b = 2 * dot(positionOffset, ray.direction);
    float c = dot(positionOffset, positionOffset) - sphere.radius * sphere.radius;
    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0) {
        hit.distance = (-b - sqrt(discriminant)) / (2 * a);
        hit.position = ray.origin + ray.direction * hit.distance;
        hit.normal = normalize(hit.position - sphere.position);
        hit.material = sphere.material;

        return hit.distance >= 0;
    }

    return false;
}

bool closestHit(Ray ray, out RayHit hit) {
    Sphere spheres[3];
    spheres[0].position = vec3(-1, 0, -2);
    spheres[0].radius = 1;
    spheres[0].material.color = vec3(1, 0, 0);
    spheres[0].material.emission_color = vec3(0, 0, 0);
    spheres[0].material.emission_strength = 0.0;

    spheres[1].position = vec3(1, 0, -2);
    spheres[1].radius = 1;
    spheres[1].material.color = vec3(0, 1, 0);
    spheres[1].material.emission_color = vec3(0, 0, 0);
    spheres[1].material.emission_strength = 0.0;

    spheres[2].position = vec3(-4, 5, -10);
    spheres[2].radius = 5;
    spheres[2].material.color = vec3(0, 0, 0);
    spheres[2].material.emission_color = vec3(1, 1, 1);
    spheres[2].material.emission_strength = 1.0;

    hit.distance = MAX_FLOAT;
    bool hit_something = false;
    for (int i = 0; i < spheres.length(); i++) {
        RayHit current_hit;
        if (intersectSphere(ray, spheres[i], current_hit) && current_hit.distance < hit.distance) {
            hit = current_hit; //se prendo qualcosa ed è più vicino lo sovrascrivo 
            hit_something = true;
        }
    }
    return hit_something;
}

layout(local_size_x = 8, local_size_y = 8) in; //dim del blocco (ogni blocco ha 64 thread)
void main() { //funzione che ogni thread esegue
    ivec2 dim_window = imageSize(window);

    vec3 result = vec3(0, 0, 0);
    vec3 ray_color = vec3(1, 1, 1);

    uint state = gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * random_seed.seed;

    if (gl_GlobalInvocationID.x > dim_window.x || gl_GlobalInvocationID.y > dim_window.y) { //controllo se sono dentro alla window
        return;
    }
    Ray ray = rayGen();
    RayHit hit;
    for (int i = 0; i < MAX_BOUNCES; i++) {
        if (closestHit(ray, hit)) {
            //creo un nuovo raggio che parte dalla sfera colpita
            ray.origin = hit.position; //per risolvere problema dovuto a errore di precisione del float
            ray.direction = randomOnHemisphere(state, hit.normal);
            
            vec3 emittedLight = hit.material.emission_color * hit.material.emission_strength;
            result += emittedLight * ray_color;
            ray_color *= (hit.material.color * dot(hit.normal, ray.direction));
        } else {
            result += vec3(0.5,0.7,1) * ray_color;
            break;
        }
    }
    
    imageStore(window, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1));
}