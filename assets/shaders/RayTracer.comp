#version 460

const int maxbounces = 4;

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Material {
    vec3 color;
    vec3 emission_color;
    float emission_strength;
};

struct Sphere {
    vec3 position;
    Material material;
    float radius;
};

struct RayHit {
    vec3 position;
    vec3 normal;
    Material material; //colore del punto dell'oggetto che vado a colpire
    float distance;
};

layout(rgba8, binding = 0) uniform image2D window; //finestra finale di output
//uniform: dati/struttura condivisi tra tutti i thread dei blocchi
layout(binding = 1) uniform RandomSeed{
    uint seed;
}random_seed;

layout(local_size_x = 8, local_size_y = 8) in; //dim del blocco (ogni blocco ha 64 thread)

float random (inout uint state) { //state è seed
    state=state*747796405+2891336453;
    uint result = ((state>>((state >>28)+4))^state)*277803737;
    result = (result >> 22)^result;
    return result/4294967295.0;
}

float randomNormalDistribution(inout uint state){
    float theta = 2*3.1415926*random(state);
    float rho = sqrt(-2*log(random(state)));
    return rho*cos(theta);
}

vec3 randomOnSphere(inout uint state) {
    return normalize(vec3(randomNormalDistribution(state), randomNormalDistribution(state), randomNormalDistribution(state)));
}

vec3 randomOnHemisphere(inout uint state, vec3 normal) {
    vec3 dir = randomOnSphere(state);
    return dir * sign(dot(normal, dir));
}

Ray rayGen() {
    vec2 uv = gl_GlobalInvocationID.xy; //identificativo univoco (vettore a tre dim di cui prendo solo x e y perchè per noi la z è 1)
    ivec2 dim_window = imageSize(window);
    
    Ray ray;
    ray.origin=vec3(0);

    uv = (uv + 0.5)/dim_window; //così l'ho mappato tra 0 e 1
    uv = uv*2.0 - 1.0;//ora tra -1 - 1
    uv.x*= float(dim_window.x)/dim_window.y; //rettangolo proporzioni
    uv.y*= -1;

    ray.direction = normalize(vec3(uv, -1)); //z fissa a -1 (regola mano destra), il davanti è negativo
    return ray;
}


bool intersectSphere(Ray ray, Sphere sphere, out RayHit hit) {
    vec3 oc = ray.origin - sphere.position;
    float a = dot(ray.direction, ray.direction); //prodotto interno per avere x^2+y^2+z^2
    float b = 2*dot(oc, ray.direction);
    //float h = dot(ray.direction, oc);
    float c = dot(oc, oc) - sphere.radius*sphere.radius;
    float discriminant = b*b - 4*a*c;

    if(discriminant>=0){
        hit.distance = (-b-sqrt(discriminant))/(2*a);
        hit.position = ray.origin + ray.direction*hit.distance; //ray direction è un vettore unitario e distance è uno scalare
        hit.normal = normalize(hit.position - sphere.position); //ho preso la normale (vettore perpendicolare a hitpoint)
        //normalizzato (lunghezza 1) dividendo per il raggio
        hit.material = sphere.material;

        return hit.distance>=0;
    }

    hit.distance = -1;
    hit.distance = 0;
    return false;
}

bool closestHit (Ray ray, out RayHit hit) {
    Sphere spheres[3];
    spheres[0].position = vec3(-1,0,-2);
    spheres[0].radius = 1;
    spheres[0].material.color = vec3(1,0,0);
    spheres[0].material.emission_color = vec3(0,0,0);
    spheres[0].material.emission_strength =0.0;


    spheres[1].position = vec3(1,0,-2);
    spheres[1].radius = 1;
    spheres[1].material.color = vec3(0,1,0);
    spheres[1].material.emission_color = vec3(0,0,0);
    spheres[1].material.emission_strength =0.0;

    spheres[2].position = vec3(-4,5,-10);
    spheres[2].radius = 5;
    spheres[2].material.color = vec3(0,0,0);
    spheres[2].material.emission_color = vec3(1,1,1);
    spheres[2].material.emission_strength =1.0;

    hit.distance = 1e20;
    bool hit_something=false;

    for(int i=0; i<spheres.length(); i++) {
        RayHit current_hit;
        if(intersectSphere(ray, spheres[i], current_hit) && current_hit.distance < hit.distance) {
            hit=current_hit; //se prendo qualcosa ed è più vicino lo sovrascrivo 
            hit_something = true;
        }
    }
    return hit_something;
}



void main() { //funzione che ogni thread esegue
    ivec2 dim_window = imageSize(window);

    vec3 result = vec3(0,0,0);
    vec3 ray_color = vec3(1,1,1);

    vec3 light_direction = vec3(0,1,0);
    uint state = gl_GlobalInvocationID.x*gl_GlobalInvocationID.y*random_seed.seed;

    if (gl_GlobalInvocationID.x > dim_window.x || gl_GlobalInvocationID.y > dim_window.y) { //controllo se sono dentro alla window
        return;
    }
    Ray ray = rayGen();
    
    //result = vec3(random(random_vec), random(random_vec), random(random_vec)) ; //debug per il random
    for(int i=0; i<maxbounces;i++) {
        RayHit hit;
        if(closestHit(ray, hit)) {
            //creo un nuovo raggio che parte dalla sfera colpita
            ray.origin = hit.position; //per risolvere problema dovuto a errore di precisione del float
            ray.direction = randomOnHemisphere(state, hit.normal);
           // result += ray_color;
           vec3 emittedLight = hit.material.emission_color*hit.material.emission_strength;
           result += emittedLight * ray_color;
           ray_color *= (hit.material.color*dot(hit.normal, ray.direction));

        }else {
            result += vec3(0.5,0.7,1)*ray_color;
            break;
        }
    }
    
    imageStore(window, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1)); //di default è blu, se interseco la sfera vado a colorarlo di rosso

}